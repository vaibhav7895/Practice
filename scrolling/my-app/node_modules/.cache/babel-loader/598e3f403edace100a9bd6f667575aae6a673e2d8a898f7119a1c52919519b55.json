{"ast":null,"code":"// import React, { useState, useEffect, useCallback } from 'react';\n\n// // Helper function to debounce events\n// const debounce = (func, delay) => {\n//   let timer;\n//   return function (...args) {\n//     const context = this;\n//     clearTimeout(timer);\n//     timer = setTimeout(() => func.apply(context, args), delay);\n//   };\n// };\n\n// // Simplified App component\n// const App = () => {\n//   const [items, setItems] = useState([]);\n//   const [loading, setLoading] = useState(false);\n//   const [page, setPage] = useState(1);\n//   const [hasMore, setHasMore] = useState(true);\n\n//   const loadItems = useCallback(async () => {\n//     if (loading || !hasMore) return;\n//     setLoading(true);\n\n//     try {\n//       // Adjust the API endpoint to include pagination, if necessary\n//       const response = await fetch(`https://639c50f416d1763ab1461101.mockapi.io/usedata?page=${page}`);\n//       const data = await response.json();\n//       console.log(data);\n\n//       if (data.length === 0) {\n//         setHasMore(false);\n//       } else {\n//         setItems((prevItems) => [...prevItems, ...data]);\n//         setPage((prevPage) => prevPage + 1);\n//       }\n//     } catch (error) {\n//       console.error('Failed to fetch items:', error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   }, [loading, hasMore, page]);\n\n//   useEffect(() => {\n//     // Debounced scroll handler\n//     const handleScroll = debounce(() => {\n//       if (loading || !hasMore) return;\n\n//       const scrollPosition = window.innerHeight + document.documentElement.scrollTop;\n//       const isBottom = scrollPosition >= document.documentElement.offsetHeight - 1; // Use a threshold to account for rounding\n\n//       if (isBottom) {\n//         loadItems();\n//       }\n//     }, 200); // 200ms debounce delay\n\n//     window.addEventListener('scroll', handleScroll);\n//     loadItems(); // Load initial items\n\n//     return () => window.removeEventListener('scroll', handleScroll);\n//   }, [loadItems, loading, hasMore]);\n\n//   return (\n//     <div>\n//       <ul>\n//         {items.map((item, index) => (\n//           <li key={index}>{item.name}</li>\n//         ))}\n//       </ul>\n//       {loading && <p>Loading...</p>}\n//       {!hasMore && <p>No more items</p>}\n//     </div>\n//   );\n// };\n\n// export default App;","map":{"version":3,"names":[],"sources":["C:/Users/vaibh/OneDrive/Desktop/react/scrolling/my-app/src/App.js"],"sourcesContent":["// import React, { useState, useEffect, useCallback } from 'react';\n\n// // Helper function to debounce events\n// const debounce = (func, delay) => {\n//   let timer;\n//   return function (...args) {\n//     const context = this;\n//     clearTimeout(timer);\n//     timer = setTimeout(() => func.apply(context, args), delay);\n//   };\n// };\n\n// // Simplified App component\n// const App = () => {\n//   const [items, setItems] = useState([]);\n//   const [loading, setLoading] = useState(false);\n//   const [page, setPage] = useState(1);\n//   const [hasMore, setHasMore] = useState(true);\n\n//   const loadItems = useCallback(async () => {\n//     if (loading || !hasMore) return;\n//     setLoading(true);\n\n//     try {\n//       // Adjust the API endpoint to include pagination, if necessary\n//       const response = await fetch(`https://639c50f416d1763ab1461101.mockapi.io/usedata?page=${page}`);\n//       const data = await response.json();\n//       console.log(data);\n\n//       if (data.length === 0) {\n//         setHasMore(false);\n//       } else {\n//         setItems((prevItems) => [...prevItems, ...data]);\n//         setPage((prevPage) => prevPage + 1);\n//       }\n//     } catch (error) {\n//       console.error('Failed to fetch items:', error);\n//     } finally {\n//       setLoading(false);\n//     }\n//   }, [loading, hasMore, page]);\n\n//   useEffect(() => {\n//     // Debounced scroll handler\n//     const handleScroll = debounce(() => {\n//       if (loading || !hasMore) return;\n\n//       const scrollPosition = window.innerHeight + document.documentElement.scrollTop;\n//       const isBottom = scrollPosition >= document.documentElement.offsetHeight - 1; // Use a threshold to account for rounding\n\n//       if (isBottom) {\n//         loadItems();\n//       }\n//     }, 200); // 200ms debounce delay\n\n//     window.addEventListener('scroll', handleScroll);\n//     loadItems(); // Load initial items\n\n//     return () => window.removeEventListener('scroll', handleScroll);\n//   }, [loadItems, loading, hasMore]);\n\n//   return (\n//     <div>\n//       <ul>\n//         {items.map((item, index) => (\n//           <li key={index}>{item.name}</li>\n//         ))}\n//       </ul>\n//       {loading && <p>Loading...</p>}\n//       {!hasMore && <p>No more items</p>}\n//     </div>\n//   );\n// };\n\n// export default App;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}